#!/usr/bin/env python

import sys
import re
import shlex
import string

from peggy.expr import *
from peggy.generator.python import PythonGenerator

re_rule = re.compile("([a-zA-Z][a-zA-Z0-9_-]*)\s*<[:=-]\s*(.*)\s*")

#~ ExprStrings = ["OR", "AND", "STRING", "STRINGI", "RANGE", "RULE", "WILDCARD"]

class Node:
	def __init__(self, t):
		self.type = t
		self.children = []
		self.str = None

class Rule:
	def __init__(self):
		self.terminal = True
		self.name = None
		self.expr = None
		self.depth = 0

	def __str__(self):
		return "%s <= %s"%(self.name, str(self.expr))

	def gen_python(self):
		lines = ["def match_rule_" + self.name + "(p, i):"]
		lines.append("\tprint \"match_rule_%s(input, %%d)\"%%(i,)"%(self.name))
		lines.append("\tresult = Result()")
		lines.append("\tresults = [" + ",".join(["Result()"] * self.expr.getDepth()) + "]")
		# lines.append("\tresults[0].node.type = " + self.getAstName())
		lines.append("\tl = 0")
		lines.append("\tm = False")
		lines.append("\tn = []")
		lines.append("\ts = [" + ",".join(["0"] * self.expr.getDepth()) + "]")
		for line in self.expr.gen_python(0, True):
			lines.append("\t" + line)
		lines.append("\tprint n")
		lines.append("\tif l > 0:")
		lines.append("\t\tprint '" + self.name + "'")
		#lines.append("\t\tresults[0].node.str = p.input[i:i+l]")
		#lines.append("\t\tresults[0].node.len = l")
		lines.append("\t\tresult.node.append(AstNode())")
		lines.append("\t\tresult.node[0].str = p.input[i:i+l]")
		lines.append("\t\tresult.node[0].len = l")
		lines.append("\t\tresult.node[0].children = results[0].node")
		lines.append("\treturn result")
		lines.append("")
		return lines

	def optimize(self):
		self.expr.optimize()

	def getAstName(self):
		return "AST_TYPE_%s"%(self.name.upper(),)

prefixes = ":!&"
suffixes = "*+?"

def extract_seq(s, d):
	l = len(s)
	i = 1
	while i < l:
		if s[i] == '\\':
			i += 1
		elif s[i] in d:
			return i+1
		i += 1
	return 0

def parse_string(s):
	r = ''
	l = len(s)
	i = 0
	while i < l:
		if s[i] == '\\':
			if i < l-1 and s[i + 1] in EscapeChar:
				r += EscapeChar[s[i + 1]]
				i += 1
			elif i < l-1 and s[i + 1] == ']':
				r += ']'
				i += 1
			else:
				return None
		else:
			r += s[i]
		i += 1
	return r

def parse_range(s):
	#print "parse_range(%s)"%(s,)
	r = ''
	l = len(s)
	i = 0
	while i < l:
		if s[i] == '\\':
			if i < l-1 and s[i + 1] in EscapeChar:
				r += EscapeChar[s[i + 1]]
				i += 1
			elif i < l-1 and s[i + 1] == ']':
				r += ']'
				i += 1
			else:
				return None
		elif s[i] == '-'  and i > 0 and i < l-1:
			r += ''.join([chr(o) for o in range(ord(s[i - 1]) + 1, ord(s[i + 1]) + 1)])
			i += 1
		else:
			r += s[i]
		i += 1
	return r

def parse_expr(s, i, e, p = ''):
	#print "parse_expr",s[i:]
	e.data.append(ExprAnd())
	e.data[-1].prefix = p
	e.data[-1].data = []
	
	subrule = False
	rule_len = len(s)
	prefix = ''
	suffix = ''
	while i < rule_len:
		if s[i] in prefixes:
			prefix = s[i]
			i += 1
		elif s[i] in suffixes:
			#while (s[i] in prefixes or s[i] in suffixes) and i < rule_len-1:
			suffix = s[i]
			i += 1
		else:
			prefix = ''
			suffix = ''

		if s[i] == '.':
			e.data[-1].data.append(ExprWildcard())
			e.data[-1].data[-1].prefix = prefix
			e.data[-1].data[-1].suffix = suffix
			i += 1
		elif s[i] == '[':
			l = extract_seq(s[i:], ']')
			if l == 0:
				print "Error: range not properly ended"
				return -1
			r = parse_range(s[i+1:i+l-1])
			if not r:
				return -1
			e.data[-1].data.append(ExprRange())
			e.data[-1].data[-1].prefix = prefix
			e.data[-1].data[-1].suffix = suffix
			e.data[-1].data[-1].data = r
			i += l
		elif s[i] == '\'':
			l = extract_seq(s[i:], '\'')
			if l == 0:
				print "Error: case-sensitive string not properly ended"
				return -1
			r = parse_string(s[i+1:i+l-1])
			if not r:
				return -1
			e.data[-1].data.append(ExprStringSensitive())
			e.data[-1].data[-1].prefix = prefix
			e.data[-1].data[-1].suffix = suffix
			e.data[-1].data[-1].data = r
			i += l
		elif s[i] == '"':
			l = extract_seq(s[i:], '"')
			if l == 0:
				print "Error: case-insensitive string not properly ended"
				return -1
			r = parse_string(s[i+1:i+l-1])
			if not r:
				return -1
			e.data[-1].data.append(ExprStringInsensitive())
			e.data[-1].data[-1].prefix = prefix
			e.data[-1].data[-1].suffix = suffix
			e.data[-1].data[-1].data = r
			i += l
		elif rule[i] in string.ascii_letters:
			l = 0
			while i+l < rule_len and (s[i+l] in string.ascii_letters or s[i+l] in string.digits):
				l += 1
			e.data[-1].data.append(ExprRule())
			e.data[-1].data[-1].prefix = prefix
			e.data[-1].data[-1].suffix = suffix
			e.data[-1].data[-1].data = s[i:i+l]
			i += l
		elif s[i] == '(':
			e.data[-1].data.append(ExprOr())
			e.data[-1].data[-1].prefix = prefix
			e.data[-1].data[-1].suffix = suffix
			e.data[-1].data[-1].data = []
			l = parse_expr(s, i+1, e.data[-1].data[-1])
			if l == 0 or l >= rule_len or s[l] != ')':
				print "Error: subrule not properly ended"
				return -1
			i = l+1

		if i >= rule_len:
			return i
		elif s[i] in suffixes:
			e.data[-1].data[-1].suffix = s[i]
			i += 1
		elif s[i] in ' \t':
			i += 1
		elif s[i] == ')':
			return i
		elif s[i] == '|' or s[i] == '/':
			e.data.append(ExprAnd())
			e.data[-1].data = []
			i += 1
		else:
			print "Error: bad char 2"
			return i
	return rule_len

def parse_rule(s, r):
	r.expr = ExprOr()
	r.expr.data = []
	l = parse_expr(s, 0, r.expr)
	return l

if __name__ == "__main__":
	rules = {}
	if len(sys.argv) < 2:
		print "Usage: %s <grammar>"%(sys.argv[0],)
		sys.exit(1)
	f = open(sys.argv[1])
	lines = f.readlines()
	name = None
	rule = None
	start = None
	last_line = 0
	error = False
	for i in range(0, len(lines)):
		line = lines[i]
		#print repr(line)
		if line[0] == '#' or line[0] == ';' or line[0] == '\n':
			continue
		match = re_rule.match(line)
		if match:
			if rule:
				l = parse_rule(rule, rules[name])
				if l != len(rule):
					print "Syntax error around line %d in rule %s at offset %d: %c"%(last_line+1,name,l,rule[l])
				elif not start:
					start = name
			name = match.group(1)
			rule = match.group(2)
			rules[name] = Rule()
			rules[name].name = name
			last_line = i
		else:
			rule += line.strip()
			last_line = i
	if rule:
		l = parse_rule(rule, rules[name])
		if l != len(rule):
			print "Syntax error at line %d in rule %s at offset %d: %c"%(i+1,name,l,rule[l])
			error = True
	
	if error:
		sys.exit(1)

	print """
def match_sensitive_string(p, i, s):
	if i + len(s) <= p.length and p.input[i:i+len(s)] == s:
		return len(s)
	else:
		return 0

def match_insensitive_string(p, i, s):
	if i + len(s) <= p.length and p.input[i:i+len(s)].lower() == s.lower():
		return len(s)
	else:
		return 0

def match_range(p, i, r):
	if i < p.length and p.input[i] in r:
		return 1
	else:
		return 0

def match_wildcard(p, i):
	if i < p.length:
		return 1
	else:
		return 0

class AstNode:
	def __init__(self):
		self.type =  0
		self.children = []
		self.str = None
		self.len = 0

class Result:
	def __init__(self):
		self.o = 0
		self.v = False
		self.n = 0
		self.node = [] # AstNode()

class Parser:
	def __init__(self, input, start):
		self.input = input
		self.length = len(input)
		self.start = start

	def parse(self):
		return self.start(self, 0)

def ast_print(node, block):
	print "\t" * block + AST_STRINGS[node.type] + "<" + node.str + ">"
	for child in node.children:
		ast_print(child, block+1)
"""

	#if "-p" in sys.argv:
	i = 0
	print "AST_STRINGS = []"
	print "AST_TYPE_UNKNOWN = 0"
	print "AST_STRINGS.append(\"UNKNOWN\")"
	for name in rules:
		print "%s = %d"%(rules[name].getAstName(),i+1)
		print "AST_STRINGS.append(\"%s\")"%(name,)
		i += 1

	for name in rules:
		# rules[name].optimize()
		print "# " + str(rules[name])
		print "# depth:",rules[name].expr.getDepth()
		for line in rules[name].gen_python():
			print line
		
		print "# ---------------------- #"
		
		generator = PythonGenerator()
		generator.gen(rules[name].expr)
		print str(generator)
		#print print_rule(rules[name])
